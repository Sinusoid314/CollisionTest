<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Collision Test</title>
</head>
<body>

<canvas id="view" width="600" height="400" style="background-color:darkgray;" tabindex="1"></canvas>

<script language="javascript">
  class Sprite
  {
    constructor(label, x, y, width, height, velocityX, velocityY)
    {
      this.label = label;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;

      this.velocityX = velocityX;
      this.velocityY = velocityY;

      this.prevX = x;
      this.prevY = y;
    }

    update(deltaTime)
    {
      this.prevX = this.x;
      this.prevY = this.y;
      this.x += this.velocityX * deltaTime;
      this.y += this.velocityY * deltaTime;
    }

    draw(context)
    {
      context.strokeRect(this.x, this.y, this.width, this.height);
      context.fillText(this.label, this.x + 15, this.y + 15);
    }
  }

  var view = document.getElementById("view");
  var viewContext = view.getContext("2d");
  var deltaTime = 0;
  var maxDeltaTime = 0.03;
  var prevTime =  0;
  var timeEpsilon = 0.01;
  var animationFrameID = 0;
  var sprite1 = new Sprite("1", 250, 250, 100, 100, -50, -50);
  var sprite2 = new Sprite("2", 10, 10, 50, 50, 0, 0);
  var spriteContact = {time: 0,
                       normalX: 0,
                       normalY: 0,
                       pointX: 0,
                       pointY: 0};

  document.addEventListener("keydown", view_onKeyDown);

  function drawLoop()
  {
    if(prevTime != 0)
      deltaTime = Math.min(((Date.now() - prevTime) / 1000), maxDeltaTime);
    prevTime = Date.now();
    animationFrameID = window.requestAnimationFrame(drawLoop);


    if((spritesWillCollide(sprite1, sprite2, deltaTime, spriteContact)))
    {
      sprite1.velocityX += spriteContact.normalX * Math.abs(sprite1.velocityX) * (1 - spriteContact.time);
      sprite1.velocityY += spriteContact.normalY * Math.abs(sprite1.velocityY) * (1 - spriteContact.time);
      sprite2.velocityX -= spriteContact.normalX * Math.abs(sprite2.velocityX) * (1 - spriteContact.time);
      sprite2.velocityY -= spriteContact.normalY * Math.abs(sprite2.velocityY) * (1 - spriteContact.time);

      console.log(spriteContact.normalX + ", " + spriteContact.normalY);
    }


    sprite1.update(deltaTime);
    sprite2.update(deltaTime);

/*
    if(spritesHaveCollided(sprite1, sprite2, deltaTime, spriteContact))
    {
      
    }
*/

    viewContext.clearRect(0, 0, viewContext.canvas.width, viewContext.canvas.height);

    sprite1.draw(viewContext);
    sprite2.draw(viewContext);
  }

  function view_onKeyDown(event)
  {
    switch(event.key)
    {
      case "ArrowUp":
        sprite2.velocityY = -100;
        break;
      case "ArrowDown":
        sprite2.velocityY = 100;
        break;
      case "ArrowLeft":
        sprite2.velocityX = -100;
        break;
      case "ArrowRight":
        sprite2.velocityX = 100;
        break;
      case "s":
        animationFrameID = window.requestAnimationFrame(drawLoop);
        break;
      case "q":
        cancelAnimationFrame(animationFrameID);
        break;
    }
  }

  function spritesWillCollide(testSprite, referenceSprite, deltaTime, contact)
  {
    var relativeVelocityX = testSprite.velocityX - referenceSprite.velocityX;
    var relativeVelocityY = testSprite.velocityY - referenceSprite.velocityY;
    var rayOriginX, rayOriginY, rayDirX, rayDirY;
    var rectX, rectY, rectWidth, rectHeight;

    if((relativeVelocityX == 0) && (relativeVelocityY == 0))
      return false;

    rayOriginX = testSprite.x + (testSprite.width / 2);
    rayOriginY = testSprite.y + (testSprite.height / 2);
    rayDirX = relativeVelocityX * deltaTime;
    rayDirY = relativeVelocityY * deltaTime;

    rectX = referenceSprite.x - (testSprite.width / 2);
    rectY = referenceSprite.y - (testSprite.height / 2);
    rectWidth = referenceSprite.width + testSprite.width;
    rectHeight = referenceSprite.height + testSprite.height;
  
    if(rayIntersectsRect(rayOriginX, rayOriginY, rayDirX, rayDirY, rectX, rectY, rectWidth, rectHeight, contact))
      return ((contact.time >= 0) && (contact.time < 1));
    else
      return false;
  }

  function spritesHaveCollided(testSprite, referenceSprite, deltaTime, contact)
  {
    var relativeVelocityX = testSprite.velocityX - referenceSprite.velocityX;
    var relativeVelocityY = testSprite.velocityY - referenceSprite.velocityY;
    var rayOriginX, rayOriginY, rayDirX, rayDirY;
    var rectX, rectY, rectWidth, rectHeight;

    if((relativeVelocityX == 0) && (relativeVelocityY == 0))
      return false;

    rayOriginX = testSprite.prevX + (testSprite.width / 2);
    rayOriginY = testSprite.prevY + (testSprite.height / 2);
    rayDirX = relativeVelocityX * deltaTime;
    rayDirY = relativeVelocityY * deltaTime;

    rectX = referenceSprite.prevX - (testSprite.width / 2);
    rectY = referenceSprite.prevY - (testSprite.height / 2);
    rectWidth = referenceSprite.width + testSprite.width;
    rectHeight = referenceSprite.height + testSprite.height;
  
    if(rayIntersectsRect(rayOriginX, rayOriginY, rayDirX, rayDirY, rectX, rectY, rectWidth, rectHeight, contact))
      return ((contact.time >= 0) && (contact.time < 1));
    else
      return false;
  }

  function rayIntersectsRect(rayOriginX, rayOriginY, rayDirX, rayDirY, rectX, rectY, rectWidth, rectHeight, contact)
  {
    var invRayDirX, invRayDirY;
    var leftTime, rightTime, topTime, bottomTime;
    var nearTimeX, farTimeX, nearTimeY, farTimeY;
    var entryTime, exitTime;

    contact.time = 0;
    contact.normalX = 0;
    contact.normalY = 0;
    contact.pointX = 0;
    contact.pointY = 0;

    invRayDirX = 1 / rayDirX;
    invRayDirY = 1 / rayDirY;

    leftTime = (rectX - rayOriginX) * invRayDirX;
    if(Math.abs(leftTime) < timeEpsilon)
      leftTime = 0;

    rightTime = (rectX + rectWidth - rayOriginX) * invRayDirX;
    if(Math.abs(rightTime) < timeEpsilon)
      rightTime = 0;

    topTime = (rectY - rayOriginY) * invRayDirY;
    if(Math.abs(topTime) < timeEpsilon)
      topTime = 0;

    bottomTime = (rectY + rectHeight - rayOriginY) * invRayDirY;
    if(Math.abs(bottomTime) < timeEpsilon)
      bottomTime = 0;

    if(Number.isNaN(leftTime) || Number.isNaN(rightTime) || Number.isNaN(topTime) || Number.isNaN(bottomTime))
      return false;

    nearTimeX = Math.min(leftTime, rightTime);
    farTimeX = Math.max(leftTime, rightTime);
    nearTimeY = Math.min(topTime, bottomTime);
    farTimeY = Math.max(topTime, bottomTime);
 
    if((nearTimeX > farTimeY) || (nearTimeY > farTimeX))
      return false;

    entryTime = Math.max(nearTimeX, nearTimeY);
    exitTime = Math.min(farTimeX, farTimeY);

    if(exitTime < 0)
      return false;

    contact.time = entryTime;

    switch(entryTime)
    {
      case topTime:
        contact.normalY = -1;
        break;
      case bottomTime:
        contact.normalY = 1;
        break;
      case leftTime:
        contact.normalX = -1;
        break;
      case rightTime:
        contact.normalX = 1;
        break;
    }
    
    contact.pointX = rayOriginX + (rayDirX * contact.time);
    contact.pointY = rayOriginY + (rayDirY * contact.time);

    return true;
  }
</script>

</body>
</html>